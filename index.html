<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Progress Bar with Explosion</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            /* 确保 canvas 可以覆盖整个屏幕 */
            position: relative;
            overflow: hidden;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* 渐变背景 */
            background: radial-gradient(circle,
                    hsl(0, 100%, 70%) 0%,
                    hsl(100, 100%, 70%)) 100%;
            animation: hueRotate 3s linear infinite;
            z-index: -2;
            /* 确保背景在最底层 */
        }

        @keyframes hueRotate {
            0% {
                filter: hue-rotate(0);
            }

            100% {
                filter: hue-rotate(360deg);
            }
        }

        /* 确保 canvas 覆盖整个屏幕并在进度条后方 */
        #boom-canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
            /* 确保 canvas 在进度条和文字之后 */
        }

        .qrcode {
            position: absolute;
            bottom: 0;
            width: 15%;
            z-index: 10;
        }


        /* 进度条容器样式 */
        #progress-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50%;
            aspect-ratio: 9 / 1;
            /* 容器背景色（未填充部分） */
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 99999px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            /* 确保文本可以绝对定位在其中 */
            position: relative;
            z-index: 5;
            /* 确保进度条在 canvas 上方 */
            transition: opacity 1s ease-out;
            /* 增加过渡让消失更平滑 */
        }

        /* 进度条消失时的样式 */
        .hidden {
            opacity: 0 !important;
            pointer-events: none;
            /* 确保它不拦截点击事件 */
        }

        /* 进度条本体样式 - 实现冲击波效果的关键 */
        #progress-bar {
            /* 基础颜色 */
            background-color: hsl(26, 100%, 62%);
            height: 100%;
            width: 0%;
            /* 动画过渡，使宽度变化更平滑 */
            transition: width 0.3s ease-out;
            position: relative;
            z-index: 1;

            /* 冲击波效果的渐变背景 */
            background-image: linear-gradient(90deg,
                    rgba(255, 255, 255, 0) 0%,
                    /* 透明左侧 */
                    rgba(255, 255, 255, 0.5) 35%,
                    /* 亮条纹开始 */
                    rgba(255, 255, 255, 0.8) 50%,
                    /* 最亮中间 */
                    rgba(255, 255, 255, 0.5) 65%,
                    /* 亮条纹结束 */
                    rgba(255, 255, 255, 0) 100%
                    /* 透明右侧 */
                );
            /* 设置渐变图案宽度并重复 */
            background-size: 200% 100%;
            /* 让渐变图案宽度是进度条宽度的2倍 */
            background-repeat: no-repeat;
            /* 启动冲击波动画 */
            animation: shockwave 1s linear infinite;
        }

        /* 冲击波动画：移动背景位置 */
        @keyframes shockwave {
            0% {
                background-position: 100% 0;
                /* 渐变图案从右侧开始（在 bar 外部）*/
            }

            100% {
                background-position: -100% 0;
                /* 渐变图案移动到左侧（穿过 bar）*/
            }
        }


        /* 进度条文本样式 */
        #progress-text {
            /* 绝对定位在容器中央 */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            line-height: 120%;
            font-size: 4vw;
            text-align: center;
            color: white;
            font-weight: bold;
            z-index: 2;
            /* 确保文本在进度条上方 */
            white-space: nowrap;
            /* 防止文本换行 */
        }

        /* 新增：最终文字消息样式 */
        #final-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 3vw;
            /* 使用 vw 使文字大小随屏幕宽度变化 */
            font-weight: bold;
            text-align: center;
            opacity: 0;
            /* 初始隐藏 */
            transition: opacity 2s ease-in-out;
            /* 添加过渡效果 */
            z-index: 10;
            /* 确保文字在 canvas (z-index: -1) 之上 */
            white-space: nowrap;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8), 0 0 30px rgba(255, 255, 255, 0.5);
            /* 添加发光效果 */
        }
    </style>
</head>

<body>
    <div id="progress-container">
        <div id="progress-bar"></div>
        <div id="progress-text">0 / 100</div>
    </div>

    <!-- 新增：最终显示的文本 -->
    <div id="final-message">Future is building…Welcome, developers of the new world.</div>

    <!-- 确保 canvas 在 body 内，并添加固定定位和 z-index 调整 -->
    <canvas id="boom-canvas"></canvas>
    <img class="qrcode" style="left: 0;" />
    <img class="qrcode" style="right: 0;" />
    <script src="./qrcode.min.js"></script>
    <script>
        // ==========================================================
        // 外部二维码逻辑 (保持不变)
        const commitPageUrl = window.location.origin + '/test.html';
        const imgElements = document.querySelectorAll('.qrcode');

        if (typeof QRCode !== 'undefined' && QRCode.toDataURL) {
            QRCode.toDataURL(commitPageUrl, function (error, url) {
                if (error) {
                    console.error(error);
                } else {
                    imgElements[0].src = url;
                    imgElements[1].src = url;
                }
            });
        }


        // ==========================================================
        // 进度条逻辑
        const barElement = document.getElementById('progress-bar');
        const textElement = document.getElementById('progress-text');
        const progressContainer = document.getElementById('progress-container');
        const finalMessage = document.getElementById('final-message'); // 新增获取最终消息元素

        let currentValue = 0; // 实际增长的值 (0 ~ 400)
        const maxValue = 400; // 目标最大值 (进度条消失点)
        const displayMax = 100; // 进度条长度达到100%时对应的值
        const intervalTime = 100; // 更新间隔时间 (毫秒)
        let progressInterval;
        let explosionStarted = false; // 标记终极爆炸是否已开始

        // ==========================================================
        // 爆炸效果 Canvas 逻辑

        const canvas = document.getElementById('boom-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];

        // --- 新增：基准宽度和缩放因子 ---
        const BASE_SCREEN_WIDTH = 1200; // 假设 1200px 是一个合理的基准宽度
        let screenScaleFactor = 1; // 屏幕缩放因子

        // 调整 Canvas 尺寸以匹配窗口
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // 计算缩放因子，并限制最小值为 0.5，防止在极小屏幕上粒子太小
            screenScaleFactor = Math.max(0.5, window.innerWidth / BASE_SCREEN_WIDTH);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // 首次调用以设置初始尺寸和因子

        // 随机颜色数组
        const colors = [
            '#FF6347', '#FFA500', '#ADFF2F', '#1E90FF', '#FF69B4', '#FFFF00', '#FFFFFF'
        ];
        function getRandomColor() {
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // 粒子类 (支持两种爆炸模式)
        class Particle {
            constructor(x, y, color, isFinalExplosion = false) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.life = 0;

                if (isFinalExplosion) {
                    // 终极爆炸：从底部向上
                    this.radius = (Math.random() * 10 + 5) * screenScaleFactor; // 更大半径
                    this.maxLife = 80 + Math.random() * 60; // 更长生命周期

                    // 角度范围：主要向上，稍微左右分散
                    const angle = -Math.PI / 2 + (Math.random() * 0.8 - 0.4);
                    // 更高的初速度，并随屏幕宽度增加
                    const speed = (Math.random() * 15 + 10) * Math.sqrt(screenScaleFactor);
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed; // vy 为负，向上
                    this.gravity = 0.2 * screenScaleFactor; // 略大重力
                } else {
                    // 进度条爆炸：向右分散
                    this.baseRadius = Math.random() * 5 + 2;
                    this.radius = this.baseRadius * screenScaleFactor;
                    this.maxLife = 40 + Math.random() * 40;

                    // 随机速度，向后方（右侧）分散
                    const angle = Math.PI * (Math.random() * 0.8 - 0.4);
                    const speed = (Math.random() * 8 + 3) * Math.sqrt(screenScaleFactor);
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.gravity = 0.1 * screenScaleFactor;
                }
            }

            update() {
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.life++;
                // 根据生命周期计算透明度
                this.alpha = 1 - this.life / this.maxLife;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.restore();
            }
        }

        // 获取进度条末端的位置（即 100% 处）
        function getBarEndPosition() {
            const rect = progressContainer.getBoundingClientRect();
            // 进度条容器右边界的屏幕坐标
            const x = rect.left + rect.width;
            // 进度条容器垂直居中的屏幕坐标
            const y = rect.top + rect.height / 2;
            return { x, y };
        }

        // 创建爆炸效果
        function createExplosion(x, y, count = 10, isFinalExplosion = false) {
            const color = getRandomColor();
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, isFinalExplosion));
            }
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            // 清理整个 canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 倒序遍历和移除已死粒子
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw();

                if (p.life >= p.maxLife) {
                    particles.splice(i, 1);
                }
            }
        }

        // 终极爆炸效果的函数
        function startFinalExplosion() {
            if (explosionStarted) return; // 避免重复触发
            explosionStarted = true;

            // 1. 隐藏进度条容器 (使用 CSS 类和过渡)
            progressContainer.classList.add('hidden');

            // 2. 显示最终文本
            finalMessage.style.opacity = 1;

            // 3. 触发底部向上的爆炸 (持续一段时间)
            const explosionDuration = 1000; // 爆炸持续 2 秒
            const startTime = Date.now();

            function explosionLoop() {
                if (Date.now() - startTime < explosionDuration) {
                    // 爆炸点：屏幕底部中心
                    const x = canvas.width / 2;
                    const y = canvas.height;

                    // 每帧创建大量粒子，使用 isFinalExplosion = true
                    createExplosion(x, y, 5, true);

                    requestAnimationFrame(explosionLoop);
                }
                // 动画循环 (animate) 会继续清理剩余粒子
            }
            explosionLoop();
        }

        // 启动动画循环
        animate();


        // ==========================================================
        // 进度条更新逻辑
        function updateProgress() {
            // 1. 根据当前值计算增量 (实现分段加速和随机性)
            let increment = 0;

            if (currentValue < 3) {
                increment = Math.random() * 0.1;
            } else if (currentValue < 10) {
                increment = Math.random() * 0.2;
            } else if (currentValue < displayMax) { // 进度条填充阶段 (0 ~ 100)
                increment = Math.random() * 2.0;
            } else if (currentValue < maxValue) { // 进度条满，内部计数阶段 (100 ~ 400)
                increment = Math.random() * 5;
            } else {
                // 达到或超过最大值，停止定时器
                clearInterval(progressInterval);
                currentValue = maxValue; // 确保最终值精确为400
            }

            // 应用增量
            currentValue += increment;

            // 确保不会超过最大值
            if (currentValue > maxValue) {
                currentValue = maxValue;
            }

            // --- 终结逻辑触发点：当 currentValue 达到 400 时 ---
            if (currentValue >= maxValue) {
                clearInterval(progressInterval);
                currentValue = maxValue;
                // 确保进度条在消失前是满的
                barElement.style.width = `100%`;
                textElement.textContent = `${maxValue} / ${displayMax}`; // 文本显示 400 / 100
                startFinalExplosion(); // 触发终结动画
                imgElements[0].style.display = 'none'
                imgElements[1].style.display = 'none'
                return;
            }


            // 2. 计算进度条的视觉百分比
            // 进度条在 currentValue 达到 100 时满
            let barPercent = (Math.min(currentValue, displayMax) / displayMax) * 100;

            // 3. 更新进度条宽度
            barElement.style.width = `${barPercent}%`;

            // 4. 更新文本显示 (显示 0~400)
            const displayText = `${Math.floor(currentValue)} / ${displayMax}`;
            textElement.textContent = displayText;

            // 5. 爆炸效果触发
            // 当 currentValue >= 100 时，进度条满，开始侧边爆炸
            const isExplosionMode = currentValue >= displayMax;
            if (isExplosionMode) {
                const pos = getBarEndPosition();
                // 每隔 intervalTime (100ms) 产生一次爆炸
                createExplosion(pos.x, pos.y, 8, false); // 传递 false 表示不是终极爆炸
            }
        }

        // 启动进度模拟
        setTimeout(() => {
            progressInterval = setInterval(updateProgress, intervalTime);
        }, 3000);

    </script>
</body>

</html>
